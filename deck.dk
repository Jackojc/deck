; `... :: foo` syntax for functions
; implement map function
; remove special function label that pushes pops address, just do it manually

; cake ( b a -> b a a b )
; flip ( a b c -> c b a )

; apply-at function to get/set an element in the stack and apply a function
; to it.

; 1 2 3 inc map

; 1 1 1
; &inc 1 apply
; dbg

; 69 >| 420 dqreplace dbg

1 2 3 6 >|
dqxchg
dbg

sys_ok

; pairs
@pdup >| over over dqgo
@ppop >| pop pop dqgo
@pnip >| nip nip dqgo
@pover >| 3 get 3 get dqgo
@pswap >| pover >| >| >| >| ppop |> |> |> |> dqgo
@ptuck >| pswap pover dqgo

; deque
@dqdup |> dup >| swap . ; dup element on deque
@dqpop |> pop . ; pop element on deque
@dqswap |> |> swap >| >| .
@dqgo pop |> .
@dqcall |> .
@dqxchg swap |> rotr >| . ; ( x cont | y -> y cont | x )

; functions
@map @.loop

@.end .

@apply ; ( fn i cont -> )
	>| swap >|
	dup get
	; |> &.
	dqcall
	swap set
dqgo

@reduce >| >| @.loop # 1 >= &.end if &.loop dqdup . @.end dqpop dqgo

@add >| + dqgo
@sub >| - dqgo
@mul >| * dqgo
@div >| / dqgo

@inc >| ++ dqgo
@dec >| -- dqgo

@sum >| &add reduce dqgo
@prod >| &mul reduce dqgo

@fact >| 1 swap iota prod dqgo
@pow2 >| dup * dqgo

@dbg >| @.loop # 0 = &.end if int &.loop . @.end dqgo

@iota >| >| @.loop
	dup ++ dup ++
	dqdup >= &.loop if
@.end dqpop dqgo

; aliases
@int &io_intln .
@hex &io_hexln .

; wrappers
@intk >| dup |> &io_intln . ; print int keep element
@hexk >| dup |> &io_hexln . ; print hex keep element




; here
; 	0 swap 0 # io_hexln swap .

; 0 here swap
; 	dup &io_intln ++
; 	dup 10 <=
; 	2 get f ? .
; @f

; 0 0 @loop ++ dup dup &io_hexln 5 < loop sys_exit ? .
