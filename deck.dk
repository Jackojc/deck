; 1 2 cake dbg
; 1 2 3 flip dbg

; 1 2 >| >| pdcpy dbg

; 1 4 iota pswap dbg
; 1 >| &inc ddo &inc ddo |> dbg
; 121 122 123
; &inc 2 apply dbg

; 1 2 3
; 1 5 iota vadd

; @fact >| 1 swap iota vmul ret
; @iota >| >| @.loop
; 	dup ++ dup ++
; 	ddup >= &.loop if
; @.end dpop ret


; &inc map
; &dec map
; 5 fac int

1 2 kint dbg

sys_ok


; stack
@cake >| pdup swap ret ; ( a b cont -> a b b a )
@flip >| rotr swap ret ; ( a b c cont -> c b a )
; @qrotl >| >| rotl |> swap dgo ; ( a b c d -> b c d a )
; @qrotr >| >| rotl |> swap dgo ; ( a b c d ->  )
; instead of the above, implement versions of rot that operate
; on the _entire stack_
; @vrotl
; @vrotl >|
	; retrieve the leftmost element and store it on the deq.
	; next we loop and set every left element equal to its right element's value.
	; lastly we pop the value we stored earlier from the deque.
; ret


; pairs
@pdup >| over over ret ; ( a b cont -> a b a b )
@ppop >| pop pop ret ; ( a b cont -> )
@pnip >| nip nip ret ; ( a b c cont -> c )
@pover >| 3 get 3 get ret ; ( a b c d -> a b c d a b )
@pswap >| >| rotr |> rotr ret ; ( a b c d -> c d a b )

@ptuck >| pswap pover ret

; deque
; @dpsh swap >| . ; ( cont | x -> | x)
@dcpy |> dup >| swap . ; ( cont | x -> x | x )
@dswap |> |> swap >| >| .
@dgo pop |> .
@dcall |> .
@dxchg swap |> rotr >| . ; ( x cont | y -> y | x )
@dpop |> pop . ; ( cont | x -> | )
@ddo |> rotl call >| . ; ( fn cont | x -> | y )

; pairs deque
@pdcpy |> |> pdup >| >| rotl . ; ( | x y -> x y | x y )

; functions
@map ; ( ... fn cont -> ... )
	>| >| # >|
@.loop
	dcpy
	0 = &.end if
	pdcpy
	swap -- apply
	&dec ddo
	&.loop .
@.end dpop dpop ret

@apply ; ( ... fn i cont -> )
	>| tuck >| >|
	get dcall |> set
ret

@reduce
	>| >|
@.loop
	# 1 >= &.end if
	&.loop dcpy .
@.end dpop ret

@add >| + ret
@sub >| - ret
@mul >| * ret
@div >| / ret

@inc >| ++ ret
@dec >| -- ret

@vadd &add swap &reduce .
@vsub &sub swap &reduce .
@vmul &mul swap &reduce .
@vdiv &div swap &reduce .

@fact >| 1 swap iota vmul ret
@fact2 >| dup 1 = &.end if dup -- fact2 * @.end ret
@sqr >| dup * ret

@dbg >| @.loop # 0 = &.end if int &.loop . @.end ret
@kdbg >| &kint map ret

@iota >| >| @.loop
	dup ++ dup ++
	dcpy >= &.loop if
@.end dpop ret

; aliases
@int &io_intln .
@hex &io_hexln .

; wrappers
@kint over rotr &io_intln . ; ( x cont -> x )
@khex over rotr &io_hexln . ; ( x cont -> x )

@ret &dgo .



; here
; 	0 swap 0 # io_hexln swap .

; 0 here swap
; 	dup &io_intln ++
; 	dup 10 <=
; 	2 get f ? .
; @f

; 0 0 @loop ++ dup dup &io_hexln 5 < loop sys_exit ? .
